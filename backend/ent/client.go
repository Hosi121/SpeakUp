// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/Hosi121/SpeakUp/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/Hosi121/SpeakUp/ent/aithemes"
	"github.com/Hosi121/SpeakUp/ent/calls"
	"github.com/Hosi121/SpeakUp/ent/friends"
	"github.com/Hosi121/SpeakUp/ent/matchings"
	"github.com/Hosi121/SpeakUp/ent/sessions"
	"github.com/Hosi121/SpeakUp/ent/users"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// AITHEMES is the client for interacting with the AITHEMES builders.
	AITHEMES *AITHEMESClient
	// CALLS is the client for interacting with the CALLS builders.
	CALLS *CALLSClient
	// FRIENDS is the client for interacting with the FRIENDS builders.
	FRIENDS *FRIENDSClient
	// MATCHINGS is the client for interacting with the MATCHINGS builders.
	MATCHINGS *MATCHINGSClient
	// SESSIONS is the client for interacting with the SESSIONS builders.
	SESSIONS *SESSIONSClient
	// USERS is the client for interacting with the USERS builders.
	USERS *USERSClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.AITHEMES = NewAITHEMESClient(c.config)
	c.CALLS = NewCALLSClient(c.config)
	c.FRIENDS = NewFRIENDSClient(c.config)
	c.MATCHINGS = NewMATCHINGSClient(c.config)
	c.SESSIONS = NewSESSIONSClient(c.config)
	c.USERS = NewUSERSClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:       ctx,
		config:    cfg,
		AITHEMES:  NewAITHEMESClient(cfg),
		CALLS:     NewCALLSClient(cfg),
		FRIENDS:   NewFRIENDSClient(cfg),
		MATCHINGS: NewMATCHINGSClient(cfg),
		SESSIONS:  NewSESSIONSClient(cfg),
		USERS:     NewUSERSClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:       ctx,
		config:    cfg,
		AITHEMES:  NewAITHEMESClient(cfg),
		CALLS:     NewCALLSClient(cfg),
		FRIENDS:   NewFRIENDSClient(cfg),
		MATCHINGS: NewMATCHINGSClient(cfg),
		SESSIONS:  NewSESSIONSClient(cfg),
		USERS:     NewUSERSClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		AITHEMES.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.AITHEMES, c.CALLS, c.FRIENDS, c.MATCHINGS, c.SESSIONS, c.USERS,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.AITHEMES, c.CALLS, c.FRIENDS, c.MATCHINGS, c.SESSIONS, c.USERS,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AITHEMESMutation:
		return c.AITHEMES.mutate(ctx, m)
	case *CALLSMutation:
		return c.CALLS.mutate(ctx, m)
	case *FRIENDSMutation:
		return c.FRIENDS.mutate(ctx, m)
	case *MATCHINGSMutation:
		return c.MATCHINGS.mutate(ctx, m)
	case *SESSIONSMutation:
		return c.SESSIONS.mutate(ctx, m)
	case *USERSMutation:
		return c.USERS.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AITHEMESClient is a client for the AITHEMES schema.
type AITHEMESClient struct {
	config
}

// NewAITHEMESClient returns a client for the AITHEMES from the given config.
func NewAITHEMESClient(c config) *AITHEMESClient {
	return &AITHEMESClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `aithemes.Hooks(f(g(h())))`.
func (c *AITHEMESClient) Use(hooks ...Hook) {
	c.hooks.AITHEMES = append(c.hooks.AITHEMES, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `aithemes.Intercept(f(g(h())))`.
func (c *AITHEMESClient) Intercept(interceptors ...Interceptor) {
	c.inters.AITHEMES = append(c.inters.AITHEMES, interceptors...)
}

// Create returns a builder for creating a AITHEMES entity.
func (c *AITHEMESClient) Create() *AITHEMESCreate {
	mutation := newAITHEMESMutation(c.config, OpCreate)
	return &AITHEMESCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AITHEMES entities.
func (c *AITHEMESClient) CreateBulk(builders ...*AITHEMESCreate) *AITHEMESCreateBulk {
	return &AITHEMESCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AITHEMESClient) MapCreateBulk(slice any, setFunc func(*AITHEMESCreate, int)) *AITHEMESCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AITHEMESCreateBulk{err: fmt.Errorf("calling to AITHEMESClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AITHEMESCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AITHEMESCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AITHEMES.
func (c *AITHEMESClient) Update() *AITHEMESUpdate {
	mutation := newAITHEMESMutation(c.config, OpUpdate)
	return &AITHEMESUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AITHEMESClient) UpdateOne(a *AITHEMES) *AITHEMESUpdateOne {
	mutation := newAITHEMESMutation(c.config, OpUpdateOne, withAITHEMES(a))
	return &AITHEMESUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AITHEMESClient) UpdateOneID(id int) *AITHEMESUpdateOne {
	mutation := newAITHEMESMutation(c.config, OpUpdateOne, withAITHEMESID(id))
	return &AITHEMESUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AITHEMES.
func (c *AITHEMESClient) Delete() *AITHEMESDelete {
	mutation := newAITHEMESMutation(c.config, OpDelete)
	return &AITHEMESDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AITHEMESClient) DeleteOne(a *AITHEMES) *AITHEMESDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AITHEMESClient) DeleteOneID(id int) *AITHEMESDeleteOne {
	builder := c.Delete().Where(aithemes.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AITHEMESDeleteOne{builder}
}

// Query returns a query builder for AITHEMES.
func (c *AITHEMESClient) Query() *AITHEMESQuery {
	return &AITHEMESQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAITHEMES},
		inters: c.Interceptors(),
	}
}

// Get returns a AITHEMES entity by its id.
func (c *AITHEMESClient) Get(ctx context.Context, id int) (*AITHEMES, error) {
	return c.Query().Where(aithemes.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AITHEMESClient) GetX(ctx context.Context, id int) *AITHEMES {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUsed queries the used edge of a AITHEMES.
func (c *AITHEMESClient) QueryUsed(a *AITHEMES) *SESSIONSQuery {
	query := (&SESSIONSClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(aithemes.Table, aithemes.FieldID, id),
			sqlgraph.To(sessions.Table, sessions.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, aithemes.UsedTable, aithemes.UsedColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AITHEMESClient) Hooks() []Hook {
	return c.hooks.AITHEMES
}

// Interceptors returns the client interceptors.
func (c *AITHEMESClient) Interceptors() []Interceptor {
	return c.inters.AITHEMES
}

func (c *AITHEMESClient) mutate(ctx context.Context, m *AITHEMESMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AITHEMESCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AITHEMESUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AITHEMESUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AITHEMESDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AITHEMES mutation op: %q", m.Op())
	}
}

// CALLSClient is a client for the CALLS schema.
type CALLSClient struct {
	config
}

// NewCALLSClient returns a client for the CALLS from the given config.
func NewCALLSClient(c config) *CALLSClient {
	return &CALLSClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `calls.Hooks(f(g(h())))`.
func (c *CALLSClient) Use(hooks ...Hook) {
	c.hooks.CALLS = append(c.hooks.CALLS, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `calls.Intercept(f(g(h())))`.
func (c *CALLSClient) Intercept(interceptors ...Interceptor) {
	c.inters.CALLS = append(c.inters.CALLS, interceptors...)
}

// Create returns a builder for creating a CALLS entity.
func (c *CALLSClient) Create() *CALLSCreate {
	mutation := newCALLSMutation(c.config, OpCreate)
	return &CALLSCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CALLS entities.
func (c *CALLSClient) CreateBulk(builders ...*CALLSCreate) *CALLSCreateBulk {
	return &CALLSCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CALLSClient) MapCreateBulk(slice any, setFunc func(*CALLSCreate, int)) *CALLSCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CALLSCreateBulk{err: fmt.Errorf("calling to CALLSClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CALLSCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CALLSCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CALLS.
func (c *CALLSClient) Update() *CALLSUpdate {
	mutation := newCALLSMutation(c.config, OpUpdate)
	return &CALLSUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CALLSClient) UpdateOne(ca *CALLS) *CALLSUpdateOne {
	mutation := newCALLSMutation(c.config, OpUpdateOne, withCALLS(ca))
	return &CALLSUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CALLSClient) UpdateOneID(id int) *CALLSUpdateOne {
	mutation := newCALLSMutation(c.config, OpUpdateOne, withCALLSID(id))
	return &CALLSUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CALLS.
func (c *CALLSClient) Delete() *CALLSDelete {
	mutation := newCALLSMutation(c.config, OpDelete)
	return &CALLSDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CALLSClient) DeleteOne(ca *CALLS) *CALLSDeleteOne {
	return c.DeleteOneID(ca.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CALLSClient) DeleteOneID(id int) *CALLSDeleteOne {
	builder := c.Delete().Where(calls.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CALLSDeleteOne{builder}
}

// Query returns a query builder for CALLS.
func (c *CALLSClient) Query() *CALLSQuery {
	return &CALLSQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCALLS},
		inters: c.Interceptors(),
	}
}

// Get returns a CALLS entity by its id.
func (c *CALLSClient) Get(ctx context.Context, id int) (*CALLS, error) {
	return c.Query().Where(calls.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CALLSClient) GetX(ctx context.Context, id int) *CALLS {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMade queries the made edge of a CALLS.
func (c *CALLSClient) QueryMade(ca *CALLS) *MATCHINGSQuery {
	query := (&MATCHINGSClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(calls.Table, calls.FieldID, id),
			sqlgraph.To(matchings.Table, matchings.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, calls.MadeTable, calls.MadeColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CALLSClient) Hooks() []Hook {
	return c.hooks.CALLS
}

// Interceptors returns the client interceptors.
func (c *CALLSClient) Interceptors() []Interceptor {
	return c.inters.CALLS
}

func (c *CALLSClient) mutate(ctx context.Context, m *CALLSMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CALLSCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CALLSUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CALLSUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CALLSDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CALLS mutation op: %q", m.Op())
	}
}

// FRIENDSClient is a client for the FRIENDS schema.
type FRIENDSClient struct {
	config
}

// NewFRIENDSClient returns a client for the FRIENDS from the given config.
func NewFRIENDSClient(c config) *FRIENDSClient {
	return &FRIENDSClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `friends.Hooks(f(g(h())))`.
func (c *FRIENDSClient) Use(hooks ...Hook) {
	c.hooks.FRIENDS = append(c.hooks.FRIENDS, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `friends.Intercept(f(g(h())))`.
func (c *FRIENDSClient) Intercept(interceptors ...Interceptor) {
	c.inters.FRIENDS = append(c.inters.FRIENDS, interceptors...)
}

// Create returns a builder for creating a FRIENDS entity.
func (c *FRIENDSClient) Create() *FRIENDSCreate {
	mutation := newFRIENDSMutation(c.config, OpCreate)
	return &FRIENDSCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FRIENDS entities.
func (c *FRIENDSClient) CreateBulk(builders ...*FRIENDSCreate) *FRIENDSCreateBulk {
	return &FRIENDSCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FRIENDSClient) MapCreateBulk(slice any, setFunc func(*FRIENDSCreate, int)) *FRIENDSCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FRIENDSCreateBulk{err: fmt.Errorf("calling to FRIENDSClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FRIENDSCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FRIENDSCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FRIENDS.
func (c *FRIENDSClient) Update() *FRIENDSUpdate {
	mutation := newFRIENDSMutation(c.config, OpUpdate)
	return &FRIENDSUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FRIENDSClient) UpdateOne(f *FRIENDS) *FRIENDSUpdateOne {
	mutation := newFRIENDSMutation(c.config, OpUpdateOne, withFRIENDS(f))
	return &FRIENDSUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FRIENDSClient) UpdateOneID(id int) *FRIENDSUpdateOne {
	mutation := newFRIENDSMutation(c.config, OpUpdateOne, withFRIENDSID(id))
	return &FRIENDSUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FRIENDS.
func (c *FRIENDSClient) Delete() *FRIENDSDelete {
	mutation := newFRIENDSMutation(c.config, OpDelete)
	return &FRIENDSDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FRIENDSClient) DeleteOne(f *FRIENDS) *FRIENDSDeleteOne {
	return c.DeleteOneID(f.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FRIENDSClient) DeleteOneID(id int) *FRIENDSDeleteOne {
	builder := c.Delete().Where(friends.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FRIENDSDeleteOne{builder}
}

// Query returns a query builder for FRIENDS.
func (c *FRIENDSClient) Query() *FRIENDSQuery {
	return &FRIENDSQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFRIENDS},
		inters: c.Interceptors(),
	}
}

// Get returns a FRIENDS entity by its id.
func (c *FRIENDSClient) Get(ctx context.Context, id int) (*FRIENDS, error) {
	return c.Query().Where(friends.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FRIENDSClient) GetX(ctx context.Context, id int) *FRIENDS {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryConnects queries the connects edge of a FRIENDS.
func (c *FRIENDSClient) QueryConnects(f *FRIENDS) *USERSQuery {
	query := (&USERSClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(friends.Table, friends.FieldID, id),
			sqlgraph.To(users.Table, users.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, friends.ConnectsTable, friends.ConnectsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FRIENDSClient) Hooks() []Hook {
	return c.hooks.FRIENDS
}

// Interceptors returns the client interceptors.
func (c *FRIENDSClient) Interceptors() []Interceptor {
	return c.inters.FRIENDS
}

func (c *FRIENDSClient) mutate(ctx context.Context, m *FRIENDSMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FRIENDSCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FRIENDSUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FRIENDSUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FRIENDSDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown FRIENDS mutation op: %q", m.Op())
	}
}

// MATCHINGSClient is a client for the MATCHINGS schema.
type MATCHINGSClient struct {
	config
}

// NewMATCHINGSClient returns a client for the MATCHINGS from the given config.
func NewMATCHINGSClient(c config) *MATCHINGSClient {
	return &MATCHINGSClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `matchings.Hooks(f(g(h())))`.
func (c *MATCHINGSClient) Use(hooks ...Hook) {
	c.hooks.MATCHINGS = append(c.hooks.MATCHINGS, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `matchings.Intercept(f(g(h())))`.
func (c *MATCHINGSClient) Intercept(interceptors ...Interceptor) {
	c.inters.MATCHINGS = append(c.inters.MATCHINGS, interceptors...)
}

// Create returns a builder for creating a MATCHINGS entity.
func (c *MATCHINGSClient) Create() *MATCHINGSCreate {
	mutation := newMATCHINGSMutation(c.config, OpCreate)
	return &MATCHINGSCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MATCHINGS entities.
func (c *MATCHINGSClient) CreateBulk(builders ...*MATCHINGSCreate) *MATCHINGSCreateBulk {
	return &MATCHINGSCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MATCHINGSClient) MapCreateBulk(slice any, setFunc func(*MATCHINGSCreate, int)) *MATCHINGSCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MATCHINGSCreateBulk{err: fmt.Errorf("calling to MATCHINGSClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MATCHINGSCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MATCHINGSCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MATCHINGS.
func (c *MATCHINGSClient) Update() *MATCHINGSUpdate {
	mutation := newMATCHINGSMutation(c.config, OpUpdate)
	return &MATCHINGSUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MATCHINGSClient) UpdateOne(m *MATCHINGS) *MATCHINGSUpdateOne {
	mutation := newMATCHINGSMutation(c.config, OpUpdateOne, withMATCHINGS(m))
	return &MATCHINGSUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MATCHINGSClient) UpdateOneID(id int) *MATCHINGSUpdateOne {
	mutation := newMATCHINGSMutation(c.config, OpUpdateOne, withMATCHINGSID(id))
	return &MATCHINGSUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MATCHINGS.
func (c *MATCHINGSClient) Delete() *MATCHINGSDelete {
	mutation := newMATCHINGSMutation(c.config, OpDelete)
	return &MATCHINGSDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MATCHINGSClient) DeleteOne(m *MATCHINGS) *MATCHINGSDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MATCHINGSClient) DeleteOneID(id int) *MATCHINGSDeleteOne {
	builder := c.Delete().Where(matchings.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MATCHINGSDeleteOne{builder}
}

// Query returns a query builder for MATCHINGS.
func (c *MATCHINGSClient) Query() *MATCHINGSQuery {
	return &MATCHINGSQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMATCHINGS},
		inters: c.Interceptors(),
	}
}

// Get returns a MATCHINGS entity by its id.
func (c *MATCHINGSClient) Get(ctx context.Context, id int) (*MATCHINGS, error) {
	return c.Query().Where(matchings.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MATCHINGSClient) GetX(ctx context.Context, id int) *MATCHINGS {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMember queries the member edge of a MATCHINGS.
func (c *MATCHINGSClient) QueryMember(m *MATCHINGS) *USERSQuery {
	query := (&USERSClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(matchings.Table, matchings.FieldID, id),
			sqlgraph.To(users.Table, users.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, matchings.MemberTable, matchings.MemberPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHad queries the had edge of a MATCHINGS.
func (c *MATCHINGSClient) QueryHad(m *MATCHINGS) *SESSIONSQuery {
	query := (&SESSIONSClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(matchings.Table, matchings.FieldID, id),
			sqlgraph.To(sessions.Table, sessions.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, matchings.HadTable, matchings.HadColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMakes queries the makes edge of a MATCHINGS.
func (c *MATCHINGSClient) QueryMakes(m *MATCHINGS) *CALLSQuery {
	query := (&CALLSClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(matchings.Table, matchings.FieldID, id),
			sqlgraph.To(calls.Table, calls.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, matchings.MakesTable, matchings.MakesColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MATCHINGSClient) Hooks() []Hook {
	return c.hooks.MATCHINGS
}

// Interceptors returns the client interceptors.
func (c *MATCHINGSClient) Interceptors() []Interceptor {
	return c.inters.MATCHINGS
}

func (c *MATCHINGSClient) mutate(ctx context.Context, m *MATCHINGSMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MATCHINGSCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MATCHINGSUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MATCHINGSUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MATCHINGSDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MATCHINGS mutation op: %q", m.Op())
	}
}

// SESSIONSClient is a client for the SESSIONS schema.
type SESSIONSClient struct {
	config
}

// NewSESSIONSClient returns a client for the SESSIONS from the given config.
func NewSESSIONSClient(c config) *SESSIONSClient {
	return &SESSIONSClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `sessions.Hooks(f(g(h())))`.
func (c *SESSIONSClient) Use(hooks ...Hook) {
	c.hooks.SESSIONS = append(c.hooks.SESSIONS, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `sessions.Intercept(f(g(h())))`.
func (c *SESSIONSClient) Intercept(interceptors ...Interceptor) {
	c.inters.SESSIONS = append(c.inters.SESSIONS, interceptors...)
}

// Create returns a builder for creating a SESSIONS entity.
func (c *SESSIONSClient) Create() *SESSIONSCreate {
	mutation := newSESSIONSMutation(c.config, OpCreate)
	return &SESSIONSCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SESSIONS entities.
func (c *SESSIONSClient) CreateBulk(builders ...*SESSIONSCreate) *SESSIONSCreateBulk {
	return &SESSIONSCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SESSIONSClient) MapCreateBulk(slice any, setFunc func(*SESSIONSCreate, int)) *SESSIONSCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SESSIONSCreateBulk{err: fmt.Errorf("calling to SESSIONSClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SESSIONSCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SESSIONSCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SESSIONS.
func (c *SESSIONSClient) Update() *SESSIONSUpdate {
	mutation := newSESSIONSMutation(c.config, OpUpdate)
	return &SESSIONSUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SESSIONSClient) UpdateOne(s *SESSIONS) *SESSIONSUpdateOne {
	mutation := newSESSIONSMutation(c.config, OpUpdateOne, withSESSIONS(s))
	return &SESSIONSUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SESSIONSClient) UpdateOneID(id int) *SESSIONSUpdateOne {
	mutation := newSESSIONSMutation(c.config, OpUpdateOne, withSESSIONSID(id))
	return &SESSIONSUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SESSIONS.
func (c *SESSIONSClient) Delete() *SESSIONSDelete {
	mutation := newSESSIONSMutation(c.config, OpDelete)
	return &SESSIONSDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SESSIONSClient) DeleteOne(s *SESSIONS) *SESSIONSDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SESSIONSClient) DeleteOneID(id int) *SESSIONSDeleteOne {
	builder := c.Delete().Where(sessions.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SESSIONSDeleteOne{builder}
}

// Query returns a query builder for SESSIONS.
func (c *SESSIONSClient) Query() *SESSIONSQuery {
	return &SESSIONSQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSESSIONS},
		inters: c.Interceptors(),
	}
}

// Get returns a SESSIONS entity by its id.
func (c *SESSIONSClient) Get(ctx context.Context, id int) (*SESSIONS, error) {
	return c.Query().Where(sessions.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SESSIONSClient) GetX(ctx context.Context, id int) *SESSIONS {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryHas queries the has edge of a SESSIONS.
func (c *SESSIONSClient) QueryHas(s *SESSIONS) *MATCHINGSQuery {
	query := (&MATCHINGSClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sessions.Table, sessions.FieldID, id),
			sqlgraph.To(matchings.Table, matchings.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, sessions.HasTable, sessions.HasColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUses queries the uses edge of a SESSIONS.
func (c *SESSIONSClient) QueryUses(s *SESSIONS) *AITHEMESQuery {
	query := (&AITHEMESClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sessions.Table, sessions.FieldID, id),
			sqlgraph.To(aithemes.Table, aithemes.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, sessions.UsesTable, sessions.UsesColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SESSIONSClient) Hooks() []Hook {
	return c.hooks.SESSIONS
}

// Interceptors returns the client interceptors.
func (c *SESSIONSClient) Interceptors() []Interceptor {
	return c.inters.SESSIONS
}

func (c *SESSIONSClient) mutate(ctx context.Context, m *SESSIONSMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SESSIONSCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SESSIONSUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SESSIONSUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SESSIONSDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SESSIONS mutation op: %q", m.Op())
	}
}

// USERSClient is a client for the USERS schema.
type USERSClient struct {
	config
}

// NewUSERSClient returns a client for the USERS from the given config.
func NewUSERSClient(c config) *USERSClient {
	return &USERSClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `users.Hooks(f(g(h())))`.
func (c *USERSClient) Use(hooks ...Hook) {
	c.hooks.USERS = append(c.hooks.USERS, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `users.Intercept(f(g(h())))`.
func (c *USERSClient) Intercept(interceptors ...Interceptor) {
	c.inters.USERS = append(c.inters.USERS, interceptors...)
}

// Create returns a builder for creating a USERS entity.
func (c *USERSClient) Create() *USERSCreate {
	mutation := newUSERSMutation(c.config, OpCreate)
	return &USERSCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of USERS entities.
func (c *USERSClient) CreateBulk(builders ...*USERSCreate) *USERSCreateBulk {
	return &USERSCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *USERSClient) MapCreateBulk(slice any, setFunc func(*USERSCreate, int)) *USERSCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &USERSCreateBulk{err: fmt.Errorf("calling to USERSClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*USERSCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &USERSCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for USERS.
func (c *USERSClient) Update() *USERSUpdate {
	mutation := newUSERSMutation(c.config, OpUpdate)
	return &USERSUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *USERSClient) UpdateOne(u *USERS) *USERSUpdateOne {
	mutation := newUSERSMutation(c.config, OpUpdateOne, withUSERS(u))
	return &USERSUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *USERSClient) UpdateOneID(id int) *USERSUpdateOne {
	mutation := newUSERSMutation(c.config, OpUpdateOne, withUSERSID(id))
	return &USERSUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for USERS.
func (c *USERSClient) Delete() *USERSDelete {
	mutation := newUSERSMutation(c.config, OpDelete)
	return &USERSDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *USERSClient) DeleteOne(u *USERS) *USERSDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *USERSClient) DeleteOneID(id int) *USERSDeleteOne {
	builder := c.Delete().Where(users.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &USERSDeleteOne{builder}
}

// Query returns a query builder for USERS.
func (c *USERSClient) Query() *USERSQuery {
	return &USERSQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUSERS},
		inters: c.Interceptors(),
	}
}

// Get returns a USERS entity by its id.
func (c *USERSClient) Get(ctx context.Context, id int) (*USERS, error) {
	return c.Query().Where(users.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *USERSClient) GetX(ctx context.Context, id int) *USERS {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryConnects queries the connects edge of a USERS.
func (c *USERSClient) QueryConnects(u *USERS) *FRIENDSQuery {
	query := (&FRIENDSClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(users.Table, users.FieldID, id),
			sqlgraph.To(friends.Table, friends.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, users.ConnectsTable, users.ConnectsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParticipates queries the participates edge of a USERS.
func (c *USERSClient) QueryParticipates(u *USERS) *MATCHINGSQuery {
	query := (&MATCHINGSClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(users.Table, users.FieldID, id),
			sqlgraph.To(matchings.Table, matchings.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, users.ParticipatesTable, users.ParticipatesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *USERSClient) Hooks() []Hook {
	return c.hooks.USERS
}

// Interceptors returns the client interceptors.
func (c *USERSClient) Interceptors() []Interceptor {
	return c.inters.USERS
}

func (c *USERSClient) mutate(ctx context.Context, m *USERSMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&USERSCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&USERSUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&USERSUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&USERSDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown USERS mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		AITHEMES, CALLS, FRIENDS, MATCHINGS, SESSIONS, USERS []ent.Hook
	}
	inters struct {
		AITHEMES, CALLS, FRIENDS, MATCHINGS, SESSIONS, USERS []ent.Interceptor
	}
)
