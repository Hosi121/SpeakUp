// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/Hosi121/SpeakUp/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/Hosi121/SpeakUp/ent/achievements"
	"github.com/Hosi121/SpeakUp/ent/ai_themes"
	"github.com/Hosi121/SpeakUp/ent/calls"
	"github.com/Hosi121/SpeakUp/ent/chats"
	"github.com/Hosi121/SpeakUp/ent/event_records"
	"github.com/Hosi121/SpeakUp/ent/events"
	"github.com/Hosi121/SpeakUp/ent/friends"
	"github.com/Hosi121/SpeakUp/ent/memos"
	"github.com/Hosi121/SpeakUp/ent/progress"
	"github.com/Hosi121/SpeakUp/ent/sessions"
	"github.com/Hosi121/SpeakUp/ent/users"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// ACHIEVEMENTS is the client for interacting with the ACHIEVEMENTS builders.
	ACHIEVEMENTS *ACHIEVEMENTSClient
	// AI_THEMES is the client for interacting with the AI_THEMES builders.
	AI_THEMES *AITHEMESClient
	// CALLS is the client for interacting with the CALLS builders.
	CALLS *CALLSClient
	// CHATS is the client for interacting with the CHATS builders.
	CHATS *CHATSClient
	// EVENTS is the client for interacting with the EVENTS builders.
	EVENTS *EVENTSClient
	// EVENT_RECORDS is the client for interacting with the EVENT_RECORDS builders.
	EVENT_RECORDS *EVENTRECORDSClient
	// FRIENDS is the client for interacting with the FRIENDS builders.
	FRIENDS *FRIENDSClient
	// MEMOS is the client for interacting with the MEMOS builders.
	MEMOS *MEMOSClient
	// PROGRESS is the client for interacting with the PROGRESS builders.
	PROGRESS *PROGRESSClient
	// SESSIONS is the client for interacting with the SESSIONS builders.
	SESSIONS *SESSIONSClient
	// USERS is the client for interacting with the USERS builders.
	USERS *USERSClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.ACHIEVEMENTS = NewACHIEVEMENTSClient(c.config)
	c.AI_THEMES = NewAITHEMESClient(c.config)
	c.CALLS = NewCALLSClient(c.config)
	c.CHATS = NewCHATSClient(c.config)
	c.EVENTS = NewEVENTSClient(c.config)
	c.EVENT_RECORDS = NewEVENTRECORDSClient(c.config)
	c.FRIENDS = NewFRIENDSClient(c.config)
	c.MEMOS = NewMEMOSClient(c.config)
	c.PROGRESS = NewPROGRESSClient(c.config)
	c.SESSIONS = NewSESSIONSClient(c.config)
	c.USERS = NewUSERSClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:           ctx,
		config:        cfg,
		ACHIEVEMENTS:  NewACHIEVEMENTSClient(cfg),
		AI_THEMES:     NewAITHEMESClient(cfg),
		CALLS:         NewCALLSClient(cfg),
		CHATS:         NewCHATSClient(cfg),
		EVENTS:        NewEVENTSClient(cfg),
		EVENT_RECORDS: NewEVENTRECORDSClient(cfg),
		FRIENDS:       NewFRIENDSClient(cfg),
		MEMOS:         NewMEMOSClient(cfg),
		PROGRESS:      NewPROGRESSClient(cfg),
		SESSIONS:      NewSESSIONSClient(cfg),
		USERS:         NewUSERSClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:           ctx,
		config:        cfg,
		ACHIEVEMENTS:  NewACHIEVEMENTSClient(cfg),
		AI_THEMES:     NewAITHEMESClient(cfg),
		CALLS:         NewCALLSClient(cfg),
		CHATS:         NewCHATSClient(cfg),
		EVENTS:        NewEVENTSClient(cfg),
		EVENT_RECORDS: NewEVENTRECORDSClient(cfg),
		FRIENDS:       NewFRIENDSClient(cfg),
		MEMOS:         NewMEMOSClient(cfg),
		PROGRESS:      NewPROGRESSClient(cfg),
		SESSIONS:      NewSESSIONSClient(cfg),
		USERS:         NewUSERSClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		ACHIEVEMENTS.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.ACHIEVEMENTS, c.AI_THEMES, c.CALLS, c.CHATS, c.EVENTS, c.EVENT_RECORDS,
		c.FRIENDS, c.MEMOS, c.PROGRESS, c.SESSIONS, c.USERS,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.ACHIEVEMENTS, c.AI_THEMES, c.CALLS, c.CHATS, c.EVENTS, c.EVENT_RECORDS,
		c.FRIENDS, c.MEMOS, c.PROGRESS, c.SESSIONS, c.USERS,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *ACHIEVEMENTSMutation:
		return c.ACHIEVEMENTS.mutate(ctx, m)
	case *AITHEMESMutation:
		return c.AI_THEMES.mutate(ctx, m)
	case *CALLSMutation:
		return c.CALLS.mutate(ctx, m)
	case *CHATSMutation:
		return c.CHATS.mutate(ctx, m)
	case *EVENTSMutation:
		return c.EVENTS.mutate(ctx, m)
	case *EVENTRECORDSMutation:
		return c.EVENT_RECORDS.mutate(ctx, m)
	case *FRIENDSMutation:
		return c.FRIENDS.mutate(ctx, m)
	case *MEMOSMutation:
		return c.MEMOS.mutate(ctx, m)
	case *PROGRESSMutation:
		return c.PROGRESS.mutate(ctx, m)
	case *SESSIONSMutation:
		return c.SESSIONS.mutate(ctx, m)
	case *USERSMutation:
		return c.USERS.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// ACHIEVEMENTSClient is a client for the ACHIEVEMENTS schema.
type ACHIEVEMENTSClient struct {
	config
}

// NewACHIEVEMENTSClient returns a client for the ACHIEVEMENTS from the given config.
func NewACHIEVEMENTSClient(c config) *ACHIEVEMENTSClient {
	return &ACHIEVEMENTSClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `achievements.Hooks(f(g(h())))`.
func (c *ACHIEVEMENTSClient) Use(hooks ...Hook) {
	c.hooks.ACHIEVEMENTS = append(c.hooks.ACHIEVEMENTS, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `achievements.Intercept(f(g(h())))`.
func (c *ACHIEVEMENTSClient) Intercept(interceptors ...Interceptor) {
	c.inters.ACHIEVEMENTS = append(c.inters.ACHIEVEMENTS, interceptors...)
}

// Create returns a builder for creating a ACHIEVEMENTS entity.
func (c *ACHIEVEMENTSClient) Create() *ACHIEVEMENTSCreate {
	mutation := newACHIEVEMENTSMutation(c.config, OpCreate)
	return &ACHIEVEMENTSCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ACHIEVEMENTS entities.
func (c *ACHIEVEMENTSClient) CreateBulk(builders ...*ACHIEVEMENTSCreate) *ACHIEVEMENTSCreateBulk {
	return &ACHIEVEMENTSCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ACHIEVEMENTSClient) MapCreateBulk(slice any, setFunc func(*ACHIEVEMENTSCreate, int)) *ACHIEVEMENTSCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ACHIEVEMENTSCreateBulk{err: fmt.Errorf("calling to ACHIEVEMENTSClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ACHIEVEMENTSCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ACHIEVEMENTSCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ACHIEVEMENTS.
func (c *ACHIEVEMENTSClient) Update() *ACHIEVEMENTSUpdate {
	mutation := newACHIEVEMENTSMutation(c.config, OpUpdate)
	return &ACHIEVEMENTSUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ACHIEVEMENTSClient) UpdateOne(a *ACHIEVEMENTS) *ACHIEVEMENTSUpdateOne {
	mutation := newACHIEVEMENTSMutation(c.config, OpUpdateOne, withACHIEVEMENTS(a))
	return &ACHIEVEMENTSUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ACHIEVEMENTSClient) UpdateOneID(id int) *ACHIEVEMENTSUpdateOne {
	mutation := newACHIEVEMENTSMutation(c.config, OpUpdateOne, withACHIEVEMENTSID(id))
	return &ACHIEVEMENTSUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ACHIEVEMENTS.
func (c *ACHIEVEMENTSClient) Delete() *ACHIEVEMENTSDelete {
	mutation := newACHIEVEMENTSMutation(c.config, OpDelete)
	return &ACHIEVEMENTSDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ACHIEVEMENTSClient) DeleteOne(a *ACHIEVEMENTS) *ACHIEVEMENTSDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ACHIEVEMENTSClient) DeleteOneID(id int) *ACHIEVEMENTSDeleteOne {
	builder := c.Delete().Where(achievements.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ACHIEVEMENTSDeleteOne{builder}
}

// Query returns a query builder for ACHIEVEMENTS.
func (c *ACHIEVEMENTSClient) Query() *ACHIEVEMENTSQuery {
	return &ACHIEVEMENTSQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeACHIEVEMENTS},
		inters: c.Interceptors(),
	}
}

// Get returns a ACHIEVEMENTS entity by its id.
func (c *ACHIEVEMENTSClient) Get(ctx context.Context, id int) (*ACHIEVEMENTS, error) {
	return c.Query().Where(achievements.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ACHIEVEMENTSClient) GetX(ctx context.Context, id int) *ACHIEVEMENTS {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryGranted queries the granted edge of a ACHIEVEMENTS.
func (c *ACHIEVEMENTSClient) QueryGranted(a *ACHIEVEMENTS) *USERSQuery {
	query := (&USERSClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(achievements.Table, achievements.FieldID, id),
			sqlgraph.To(users.Table, users.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, achievements.GrantedTable, achievements.GrantedColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ACHIEVEMENTSClient) Hooks() []Hook {
	return c.hooks.ACHIEVEMENTS
}

// Interceptors returns the client interceptors.
func (c *ACHIEVEMENTSClient) Interceptors() []Interceptor {
	return c.inters.ACHIEVEMENTS
}

func (c *ACHIEVEMENTSClient) mutate(ctx context.Context, m *ACHIEVEMENTSMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ACHIEVEMENTSCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ACHIEVEMENTSUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ACHIEVEMENTSUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ACHIEVEMENTSDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ACHIEVEMENTS mutation op: %q", m.Op())
	}
}

// AITHEMESClient is a client for the AI_THEMES schema.
type AITHEMESClient struct {
	config
}

// NewAITHEMESClient returns a client for the AI_THEMES from the given config.
func NewAITHEMESClient(c config) *AITHEMESClient {
	return &AITHEMESClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `ai_themes.Hooks(f(g(h())))`.
func (c *AITHEMESClient) Use(hooks ...Hook) {
	c.hooks.AI_THEMES = append(c.hooks.AI_THEMES, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `ai_themes.Intercept(f(g(h())))`.
func (c *AITHEMESClient) Intercept(interceptors ...Interceptor) {
	c.inters.AI_THEMES = append(c.inters.AI_THEMES, interceptors...)
}

// Create returns a builder for creating a AI_THEMES entity.
func (c *AITHEMESClient) Create() *AITHEMESCreate {
	mutation := newAITHEMESMutation(c.config, OpCreate)
	return &AITHEMESCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AI_THEMES entities.
func (c *AITHEMESClient) CreateBulk(builders ...*AITHEMESCreate) *AITHEMESCreateBulk {
	return &AITHEMESCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AITHEMESClient) MapCreateBulk(slice any, setFunc func(*AITHEMESCreate, int)) *AITHEMESCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AITHEMESCreateBulk{err: fmt.Errorf("calling to AITHEMESClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AITHEMESCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AITHEMESCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AI_THEMES.
func (c *AITHEMESClient) Update() *AITHEMESUpdate {
	mutation := newAITHEMESMutation(c.config, OpUpdate)
	return &AITHEMESUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AITHEMESClient) UpdateOne(at *AI_THEMES) *AITHEMESUpdateOne {
	mutation := newAITHEMESMutation(c.config, OpUpdateOne, withAI_THEMES(at))
	return &AITHEMESUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AITHEMESClient) UpdateOneID(id int) *AITHEMESUpdateOne {
	mutation := newAITHEMESMutation(c.config, OpUpdateOne, withAI_THEMESID(id))
	return &AITHEMESUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AI_THEMES.
func (c *AITHEMESClient) Delete() *AITHEMESDelete {
	mutation := newAITHEMESMutation(c.config, OpDelete)
	return &AITHEMESDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AITHEMESClient) DeleteOne(at *AI_THEMES) *AITHEMESDeleteOne {
	return c.DeleteOneID(at.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AITHEMESClient) DeleteOneID(id int) *AITHEMESDeleteOne {
	builder := c.Delete().Where(ai_themes.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AITHEMESDeleteOne{builder}
}

// Query returns a query builder for AI_THEMES.
func (c *AITHEMESClient) Query() *AITHEMESQuery {
	return &AITHEMESQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAITHEMES},
		inters: c.Interceptors(),
	}
}

// Get returns a AI_THEMES entity by its id.
func (c *AITHEMESClient) Get(ctx context.Context, id int) (*AI_THEMES, error) {
	return c.Query().Where(ai_themes.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AITHEMESClient) GetX(ctx context.Context, id int) *AI_THEMES {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUsed queries the used edge of a AI_THEMES.
func (c *AITHEMESClient) QueryUsed(at *AI_THEMES) *EVENTSQuery {
	query := (&EVENTSClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := at.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ai_themes.Table, ai_themes.FieldID, id),
			sqlgraph.To(events.Table, events.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, ai_themes.UsedTable, ai_themes.UsedColumn),
		)
		fromV = sqlgraph.Neighbors(at.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AITHEMESClient) Hooks() []Hook {
	return c.hooks.AI_THEMES
}

// Interceptors returns the client interceptors.
func (c *AITHEMESClient) Interceptors() []Interceptor {
	return c.inters.AI_THEMES
}

func (c *AITHEMESClient) mutate(ctx context.Context, m *AITHEMESMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AITHEMESCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AITHEMESUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AITHEMESUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AITHEMESDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AI_THEMES mutation op: %q", m.Op())
	}
}

// CALLSClient is a client for the CALLS schema.
type CALLSClient struct {
	config
}

// NewCALLSClient returns a client for the CALLS from the given config.
func NewCALLSClient(c config) *CALLSClient {
	return &CALLSClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `calls.Hooks(f(g(h())))`.
func (c *CALLSClient) Use(hooks ...Hook) {
	c.hooks.CALLS = append(c.hooks.CALLS, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `calls.Intercept(f(g(h())))`.
func (c *CALLSClient) Intercept(interceptors ...Interceptor) {
	c.inters.CALLS = append(c.inters.CALLS, interceptors...)
}

// Create returns a builder for creating a CALLS entity.
func (c *CALLSClient) Create() *CALLSCreate {
	mutation := newCALLSMutation(c.config, OpCreate)
	return &CALLSCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CALLS entities.
func (c *CALLSClient) CreateBulk(builders ...*CALLSCreate) *CALLSCreateBulk {
	return &CALLSCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CALLSClient) MapCreateBulk(slice any, setFunc func(*CALLSCreate, int)) *CALLSCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CALLSCreateBulk{err: fmt.Errorf("calling to CALLSClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CALLSCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CALLSCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CALLS.
func (c *CALLSClient) Update() *CALLSUpdate {
	mutation := newCALLSMutation(c.config, OpUpdate)
	return &CALLSUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CALLSClient) UpdateOne(ca *CALLS) *CALLSUpdateOne {
	mutation := newCALLSMutation(c.config, OpUpdateOne, withCALLS(ca))
	return &CALLSUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CALLSClient) UpdateOneID(id int) *CALLSUpdateOne {
	mutation := newCALLSMutation(c.config, OpUpdateOne, withCALLSID(id))
	return &CALLSUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CALLS.
func (c *CALLSClient) Delete() *CALLSDelete {
	mutation := newCALLSMutation(c.config, OpDelete)
	return &CALLSDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CALLSClient) DeleteOne(ca *CALLS) *CALLSDeleteOne {
	return c.DeleteOneID(ca.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CALLSClient) DeleteOneID(id int) *CALLSDeleteOne {
	builder := c.Delete().Where(calls.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CALLSDeleteOne{builder}
}

// Query returns a query builder for CALLS.
func (c *CALLSClient) Query() *CALLSQuery {
	return &CALLSQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCALLS},
		inters: c.Interceptors(),
	}
}

// Get returns a CALLS entity by its id.
func (c *CALLSClient) Get(ctx context.Context, id int) (*CALLS, error) {
	return c.Query().Where(calls.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CALLSClient) GetX(ctx context.Context, id int) *CALLS {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMade queries the made edge of a CALLS.
func (c *CALLSClient) QueryMade(ca *CALLS) *SESSIONSQuery {
	query := (&SESSIONSClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(calls.Table, calls.FieldID, id),
			sqlgraph.To(sessions.Table, sessions.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, calls.MadeTable, calls.MadeColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CALLSClient) Hooks() []Hook {
	return c.hooks.CALLS
}

// Interceptors returns the client interceptors.
func (c *CALLSClient) Interceptors() []Interceptor {
	return c.inters.CALLS
}

func (c *CALLSClient) mutate(ctx context.Context, m *CALLSMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CALLSCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CALLSUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CALLSUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CALLSDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CALLS mutation op: %q", m.Op())
	}
}

// CHATSClient is a client for the CHATS schema.
type CHATSClient struct {
	config
}

// NewCHATSClient returns a client for the CHATS from the given config.
func NewCHATSClient(c config) *CHATSClient {
	return &CHATSClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `chats.Hooks(f(g(h())))`.
func (c *CHATSClient) Use(hooks ...Hook) {
	c.hooks.CHATS = append(c.hooks.CHATS, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `chats.Intercept(f(g(h())))`.
func (c *CHATSClient) Intercept(interceptors ...Interceptor) {
	c.inters.CHATS = append(c.inters.CHATS, interceptors...)
}

// Create returns a builder for creating a CHATS entity.
func (c *CHATSClient) Create() *CHATSCreate {
	mutation := newCHATSMutation(c.config, OpCreate)
	return &CHATSCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CHATS entities.
func (c *CHATSClient) CreateBulk(builders ...*CHATSCreate) *CHATSCreateBulk {
	return &CHATSCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CHATSClient) MapCreateBulk(slice any, setFunc func(*CHATSCreate, int)) *CHATSCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CHATSCreateBulk{err: fmt.Errorf("calling to CHATSClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CHATSCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CHATSCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CHATS.
func (c *CHATSClient) Update() *CHATSUpdate {
	mutation := newCHATSMutation(c.config, OpUpdate)
	return &CHATSUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CHATSClient) UpdateOne(ch *CHATS) *CHATSUpdateOne {
	mutation := newCHATSMutation(c.config, OpUpdateOne, withCHATS(ch))
	return &CHATSUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CHATSClient) UpdateOneID(id int) *CHATSUpdateOne {
	mutation := newCHATSMutation(c.config, OpUpdateOne, withCHATSID(id))
	return &CHATSUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CHATS.
func (c *CHATSClient) Delete() *CHATSDelete {
	mutation := newCHATSMutation(c.config, OpDelete)
	return &CHATSDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CHATSClient) DeleteOne(ch *CHATS) *CHATSDeleteOne {
	return c.DeleteOneID(ch.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CHATSClient) DeleteOneID(id int) *CHATSDeleteOne {
	builder := c.Delete().Where(chats.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CHATSDeleteOne{builder}
}

// Query returns a query builder for CHATS.
func (c *CHATSClient) Query() *CHATSQuery {
	return &CHATSQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCHATS},
		inters: c.Interceptors(),
	}
}

// Get returns a CHATS entity by its id.
func (c *CHATSClient) Get(ctx context.Context, id int) (*CHATS, error) {
	return c.Query().Where(chats.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CHATSClient) GetX(ctx context.Context, id int) *CHATS {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryHad queries the had edge of a CHATS.
func (c *CHATSClient) QueryHad(ch *CHATS) *FRIENDSQuery {
	query := (&FRIENDSClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ch.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(chats.Table, chats.FieldID, id),
			sqlgraph.To(friends.Table, friends.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, chats.HadTable, chats.HadColumn),
		)
		fromV = sqlgraph.Neighbors(ch.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CHATSClient) Hooks() []Hook {
	return c.hooks.CHATS
}

// Interceptors returns the client interceptors.
func (c *CHATSClient) Interceptors() []Interceptor {
	return c.inters.CHATS
}

func (c *CHATSClient) mutate(ctx context.Context, m *CHATSMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CHATSCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CHATSUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CHATSUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CHATSDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CHATS mutation op: %q", m.Op())
	}
}

// EVENTSClient is a client for the EVENTS schema.
type EVENTSClient struct {
	config
}

// NewEVENTSClient returns a client for the EVENTS from the given config.
func NewEVENTSClient(c config) *EVENTSClient {
	return &EVENTSClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `events.Hooks(f(g(h())))`.
func (c *EVENTSClient) Use(hooks ...Hook) {
	c.hooks.EVENTS = append(c.hooks.EVENTS, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `events.Intercept(f(g(h())))`.
func (c *EVENTSClient) Intercept(interceptors ...Interceptor) {
	c.inters.EVENTS = append(c.inters.EVENTS, interceptors...)
}

// Create returns a builder for creating a EVENTS entity.
func (c *EVENTSClient) Create() *EVENTSCreate {
	mutation := newEVENTSMutation(c.config, OpCreate)
	return &EVENTSCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EVENTS entities.
func (c *EVENTSClient) CreateBulk(builders ...*EVENTSCreate) *EVENTSCreateBulk {
	return &EVENTSCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EVENTSClient) MapCreateBulk(slice any, setFunc func(*EVENTSCreate, int)) *EVENTSCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EVENTSCreateBulk{err: fmt.Errorf("calling to EVENTSClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EVENTSCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EVENTSCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EVENTS.
func (c *EVENTSClient) Update() *EVENTSUpdate {
	mutation := newEVENTSMutation(c.config, OpUpdate)
	return &EVENTSUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EVENTSClient) UpdateOne(e *EVENTS) *EVENTSUpdateOne {
	mutation := newEVENTSMutation(c.config, OpUpdateOne, withEVENTS(e))
	return &EVENTSUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EVENTSClient) UpdateOneID(id int) *EVENTSUpdateOne {
	mutation := newEVENTSMutation(c.config, OpUpdateOne, withEVENTSID(id))
	return &EVENTSUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EVENTS.
func (c *EVENTSClient) Delete() *EVENTSDelete {
	mutation := newEVENTSMutation(c.config, OpDelete)
	return &EVENTSDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EVENTSClient) DeleteOne(e *EVENTS) *EVENTSDeleteOne {
	return c.DeleteOneID(e.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EVENTSClient) DeleteOneID(id int) *EVENTSDeleteOne {
	builder := c.Delete().Where(events.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EVENTSDeleteOne{builder}
}

// Query returns a query builder for EVENTS.
func (c *EVENTSClient) Query() *EVENTSQuery {
	return &EVENTSQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEVENTS},
		inters: c.Interceptors(),
	}
}

// Get returns a EVENTS entity by its id.
func (c *EVENTSClient) Get(ctx context.Context, id int) (*EVENTS, error) {
	return c.Query().Where(events.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EVENTSClient) GetX(ctx context.Context, id int) *EVENTS {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryParticipated queries the participated edge of a EVENTS.
func (c *EVENTSClient) QueryParticipated(e *EVENTS) *EVENTRECORDSQuery {
	query := (&EVENTRECORDSClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(events.Table, events.FieldID, id),
			sqlgraph.To(event_records.Table, event_records.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, events.ParticipatedTable, events.ParticipatedColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUses queries the uses edge of a EVENTS.
func (c *EVENTSClient) QueryUses(e *EVENTS) *AITHEMESQuery {
	query := (&AITHEMESClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(events.Table, events.FieldID, id),
			sqlgraph.To(ai_themes.Table, ai_themes.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, events.UsesTable, events.UsesColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EVENTSClient) Hooks() []Hook {
	return c.hooks.EVENTS
}

// Interceptors returns the client interceptors.
func (c *EVENTSClient) Interceptors() []Interceptor {
	return c.inters.EVENTS
}

func (c *EVENTSClient) mutate(ctx context.Context, m *EVENTSMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EVENTSCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EVENTSUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EVENTSUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EVENTSDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown EVENTS mutation op: %q", m.Op())
	}
}

// EVENTRECORDSClient is a client for the EVENT_RECORDS schema.
type EVENTRECORDSClient struct {
	config
}

// NewEVENTRECORDSClient returns a client for the EVENT_RECORDS from the given config.
func NewEVENTRECORDSClient(c config) *EVENTRECORDSClient {
	return &EVENTRECORDSClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `event_records.Hooks(f(g(h())))`.
func (c *EVENTRECORDSClient) Use(hooks ...Hook) {
	c.hooks.EVENT_RECORDS = append(c.hooks.EVENT_RECORDS, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `event_records.Intercept(f(g(h())))`.
func (c *EVENTRECORDSClient) Intercept(interceptors ...Interceptor) {
	c.inters.EVENT_RECORDS = append(c.inters.EVENT_RECORDS, interceptors...)
}

// Create returns a builder for creating a EVENT_RECORDS entity.
func (c *EVENTRECORDSClient) Create() *EVENTRECORDSCreate {
	mutation := newEVENTRECORDSMutation(c.config, OpCreate)
	return &EVENTRECORDSCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EVENT_RECORDS entities.
func (c *EVENTRECORDSClient) CreateBulk(builders ...*EVENTRECORDSCreate) *EVENTRECORDSCreateBulk {
	return &EVENTRECORDSCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EVENTRECORDSClient) MapCreateBulk(slice any, setFunc func(*EVENTRECORDSCreate, int)) *EVENTRECORDSCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EVENTRECORDSCreateBulk{err: fmt.Errorf("calling to EVENTRECORDSClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EVENTRECORDSCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EVENTRECORDSCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EVENT_RECORDS.
func (c *EVENTRECORDSClient) Update() *EVENTRECORDSUpdate {
	mutation := newEVENTRECORDSMutation(c.config, OpUpdate)
	return &EVENTRECORDSUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EVENTRECORDSClient) UpdateOne(er *EVENT_RECORDS) *EVENTRECORDSUpdateOne {
	mutation := newEVENTRECORDSMutation(c.config, OpUpdateOne, withEVENT_RECORDS(er))
	return &EVENTRECORDSUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EVENTRECORDSClient) UpdateOneID(id int) *EVENTRECORDSUpdateOne {
	mutation := newEVENTRECORDSMutation(c.config, OpUpdateOne, withEVENT_RECORDSID(id))
	return &EVENTRECORDSUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EVENT_RECORDS.
func (c *EVENTRECORDSClient) Delete() *EVENTRECORDSDelete {
	mutation := newEVENTRECORDSMutation(c.config, OpDelete)
	return &EVENTRECORDSDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EVENTRECORDSClient) DeleteOne(er *EVENT_RECORDS) *EVENTRECORDSDeleteOne {
	return c.DeleteOneID(er.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EVENTRECORDSClient) DeleteOneID(id int) *EVENTRECORDSDeleteOne {
	builder := c.Delete().Where(event_records.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EVENTRECORDSDeleteOne{builder}
}

// Query returns a query builder for EVENT_RECORDS.
func (c *EVENTRECORDSClient) Query() *EVENTRECORDSQuery {
	return &EVENTRECORDSQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEVENTRECORDS},
		inters: c.Interceptors(),
	}
}

// Get returns a EVENT_RECORDS entity by its id.
func (c *EVENTRECORDSClient) Get(ctx context.Context, id int) (*EVENT_RECORDS, error) {
	return c.Query().Where(event_records.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EVENTRECORDSClient) GetX(ctx context.Context, id int) *EVENT_RECORDS {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMade queries the made edge of a EVENT_RECORDS.
func (c *EVENTRECORDSClient) QueryMade(er *EVENT_RECORDS) *USERSQuery {
	query := (&USERSClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := er.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event_records.Table, event_records.FieldID, id),
			sqlgraph.To(users.Table, users.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, event_records.MadeTable, event_records.MadeColumn),
		)
		fromV = sqlgraph.Neighbors(er.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParticipates queries the participates edge of a EVENT_RECORDS.
func (c *EVENTRECORDSClient) QueryParticipates(er *EVENT_RECORDS) *EVENTSQuery {
	query := (&EVENTSClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := er.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event_records.Table, event_records.FieldID, id),
			sqlgraph.To(events.Table, events.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, event_records.ParticipatesTable, event_records.ParticipatesColumn),
		)
		fromV = sqlgraph.Neighbors(er.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHas queries the has edge of a EVENT_RECORDS.
func (c *EVENTRECORDSClient) QueryHas(er *EVENT_RECORDS) *SESSIONSQuery {
	query := (&SESSIONSClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := er.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event_records.Table, event_records.FieldID, id),
			sqlgraph.To(sessions.Table, sessions.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, event_records.HasTable, event_records.HasColumn),
		)
		fromV = sqlgraph.Neighbors(er.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EVENTRECORDSClient) Hooks() []Hook {
	return c.hooks.EVENT_RECORDS
}

// Interceptors returns the client interceptors.
func (c *EVENTRECORDSClient) Interceptors() []Interceptor {
	return c.inters.EVENT_RECORDS
}

func (c *EVENTRECORDSClient) mutate(ctx context.Context, m *EVENTRECORDSMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EVENTRECORDSCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EVENTRECORDSUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EVENTRECORDSUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EVENTRECORDSDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown EVENT_RECORDS mutation op: %q", m.Op())
	}
}

// FRIENDSClient is a client for the FRIENDS schema.
type FRIENDSClient struct {
	config
}

// NewFRIENDSClient returns a client for the FRIENDS from the given config.
func NewFRIENDSClient(c config) *FRIENDSClient {
	return &FRIENDSClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `friends.Hooks(f(g(h())))`.
func (c *FRIENDSClient) Use(hooks ...Hook) {
	c.hooks.FRIENDS = append(c.hooks.FRIENDS, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `friends.Intercept(f(g(h())))`.
func (c *FRIENDSClient) Intercept(interceptors ...Interceptor) {
	c.inters.FRIENDS = append(c.inters.FRIENDS, interceptors...)
}

// Create returns a builder for creating a FRIENDS entity.
func (c *FRIENDSClient) Create() *FRIENDSCreate {
	mutation := newFRIENDSMutation(c.config, OpCreate)
	return &FRIENDSCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FRIENDS entities.
func (c *FRIENDSClient) CreateBulk(builders ...*FRIENDSCreate) *FRIENDSCreateBulk {
	return &FRIENDSCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FRIENDSClient) MapCreateBulk(slice any, setFunc func(*FRIENDSCreate, int)) *FRIENDSCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FRIENDSCreateBulk{err: fmt.Errorf("calling to FRIENDSClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FRIENDSCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FRIENDSCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FRIENDS.
func (c *FRIENDSClient) Update() *FRIENDSUpdate {
	mutation := newFRIENDSMutation(c.config, OpUpdate)
	return &FRIENDSUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FRIENDSClient) UpdateOne(f *FRIENDS) *FRIENDSUpdateOne {
	mutation := newFRIENDSMutation(c.config, OpUpdateOne, withFRIENDS(f))
	return &FRIENDSUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FRIENDSClient) UpdateOneID(id int) *FRIENDSUpdateOne {
	mutation := newFRIENDSMutation(c.config, OpUpdateOne, withFRIENDSID(id))
	return &FRIENDSUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FRIENDS.
func (c *FRIENDSClient) Delete() *FRIENDSDelete {
	mutation := newFRIENDSMutation(c.config, OpDelete)
	return &FRIENDSDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FRIENDSClient) DeleteOne(f *FRIENDS) *FRIENDSDeleteOne {
	return c.DeleteOneID(f.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FRIENDSClient) DeleteOneID(id int) *FRIENDSDeleteOne {
	builder := c.Delete().Where(friends.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FRIENDSDeleteOne{builder}
}

// Query returns a query builder for FRIENDS.
func (c *FRIENDSClient) Query() *FRIENDSQuery {
	return &FRIENDSQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFRIENDS},
		inters: c.Interceptors(),
	}
}

// Get returns a FRIENDS entity by its id.
func (c *FRIENDSClient) Get(ctx context.Context, id int) (*FRIENDS, error) {
	return c.Query().Where(friends.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FRIENDSClient) GetX(ctx context.Context, id int) *FRIENDS {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryConnects queries the connects edge of a FRIENDS.
func (c *FRIENDSClient) QueryConnects(f *FRIENDS) *USERSQuery {
	query := (&USERSClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(friends.Table, friends.FieldID, id),
			sqlgraph.To(users.Table, users.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, friends.ConnectsTable, friends.ConnectsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHas queries the has edge of a FRIENDS.
func (c *FRIENDSClient) QueryHas(f *FRIENDS) *CHATSQuery {
	query := (&CHATSClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(friends.Table, friends.FieldID, id),
			sqlgraph.To(chats.Table, chats.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, friends.HasTable, friends.HasColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FRIENDSClient) Hooks() []Hook {
	return c.hooks.FRIENDS
}

// Interceptors returns the client interceptors.
func (c *FRIENDSClient) Interceptors() []Interceptor {
	return c.inters.FRIENDS
}

func (c *FRIENDSClient) mutate(ctx context.Context, m *FRIENDSMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FRIENDSCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FRIENDSUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FRIENDSUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FRIENDSDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown FRIENDS mutation op: %q", m.Op())
	}
}

// MEMOSClient is a client for the MEMOS schema.
type MEMOSClient struct {
	config
}

// NewMEMOSClient returns a client for the MEMOS from the given config.
func NewMEMOSClient(c config) *MEMOSClient {
	return &MEMOSClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `memos.Hooks(f(g(h())))`.
func (c *MEMOSClient) Use(hooks ...Hook) {
	c.hooks.MEMOS = append(c.hooks.MEMOS, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `memos.Intercept(f(g(h())))`.
func (c *MEMOSClient) Intercept(interceptors ...Interceptor) {
	c.inters.MEMOS = append(c.inters.MEMOS, interceptors...)
}

// Create returns a builder for creating a MEMOS entity.
func (c *MEMOSClient) Create() *MEMOSCreate {
	mutation := newMEMOSMutation(c.config, OpCreate)
	return &MEMOSCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MEMOS entities.
func (c *MEMOSClient) CreateBulk(builders ...*MEMOSCreate) *MEMOSCreateBulk {
	return &MEMOSCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MEMOSClient) MapCreateBulk(slice any, setFunc func(*MEMOSCreate, int)) *MEMOSCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MEMOSCreateBulk{err: fmt.Errorf("calling to MEMOSClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MEMOSCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MEMOSCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MEMOS.
func (c *MEMOSClient) Update() *MEMOSUpdate {
	mutation := newMEMOSMutation(c.config, OpUpdate)
	return &MEMOSUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MEMOSClient) UpdateOne(m *MEMOS) *MEMOSUpdateOne {
	mutation := newMEMOSMutation(c.config, OpUpdateOne, withMEMOS(m))
	return &MEMOSUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MEMOSClient) UpdateOneID(id int) *MEMOSUpdateOne {
	mutation := newMEMOSMutation(c.config, OpUpdateOne, withMEMOSID(id))
	return &MEMOSUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MEMOS.
func (c *MEMOSClient) Delete() *MEMOSDelete {
	mutation := newMEMOSMutation(c.config, OpDelete)
	return &MEMOSDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MEMOSClient) DeleteOne(m *MEMOS) *MEMOSDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MEMOSClient) DeleteOneID(id int) *MEMOSDeleteOne {
	builder := c.Delete().Where(memos.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MEMOSDeleteOne{builder}
}

// Query returns a query builder for MEMOS.
func (c *MEMOSClient) Query() *MEMOSQuery {
	return &MEMOSQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMEMOS},
		inters: c.Interceptors(),
	}
}

// Get returns a MEMOS entity by its id.
func (c *MEMOSClient) Get(ctx context.Context, id int) (*MEMOS, error) {
	return c.Query().Where(memos.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MEMOSClient) GetX(ctx context.Context, id int) *MEMOS {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPrepared queries the prepared edge of a MEMOS.
func (c *MEMOSClient) QueryPrepared(m *MEMOS) *USERSQuery {
	query := (&USERSClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(memos.Table, memos.FieldID, id),
			sqlgraph.To(users.Table, users.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, memos.PreparedTable, memos.PreparedColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MEMOSClient) Hooks() []Hook {
	return c.hooks.MEMOS
}

// Interceptors returns the client interceptors.
func (c *MEMOSClient) Interceptors() []Interceptor {
	return c.inters.MEMOS
}

func (c *MEMOSClient) mutate(ctx context.Context, m *MEMOSMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MEMOSCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MEMOSUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MEMOSUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MEMOSDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MEMOS mutation op: %q", m.Op())
	}
}

// PROGRESSClient is a client for the PROGRESS schema.
type PROGRESSClient struct {
	config
}

// NewPROGRESSClient returns a client for the PROGRESS from the given config.
func NewPROGRESSClient(c config) *PROGRESSClient {
	return &PROGRESSClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `progress.Hooks(f(g(h())))`.
func (c *PROGRESSClient) Use(hooks ...Hook) {
	c.hooks.PROGRESS = append(c.hooks.PROGRESS, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `progress.Intercept(f(g(h())))`.
func (c *PROGRESSClient) Intercept(interceptors ...Interceptor) {
	c.inters.PROGRESS = append(c.inters.PROGRESS, interceptors...)
}

// Create returns a builder for creating a PROGRESS entity.
func (c *PROGRESSClient) Create() *PROGRESSCreate {
	mutation := newPROGRESSMutation(c.config, OpCreate)
	return &PROGRESSCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PROGRESS entities.
func (c *PROGRESSClient) CreateBulk(builders ...*PROGRESSCreate) *PROGRESSCreateBulk {
	return &PROGRESSCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PROGRESSClient) MapCreateBulk(slice any, setFunc func(*PROGRESSCreate, int)) *PROGRESSCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PROGRESSCreateBulk{err: fmt.Errorf("calling to PROGRESSClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PROGRESSCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PROGRESSCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PROGRESS.
func (c *PROGRESSClient) Update() *PROGRESSUpdate {
	mutation := newPROGRESSMutation(c.config, OpUpdate)
	return &PROGRESSUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PROGRESSClient) UpdateOne(pr *PROGRESS) *PROGRESSUpdateOne {
	mutation := newPROGRESSMutation(c.config, OpUpdateOne, withPROGRESS(pr))
	return &PROGRESSUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PROGRESSClient) UpdateOneID(id int) *PROGRESSUpdateOne {
	mutation := newPROGRESSMutation(c.config, OpUpdateOne, withPROGRESSID(id))
	return &PROGRESSUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PROGRESS.
func (c *PROGRESSClient) Delete() *PROGRESSDelete {
	mutation := newPROGRESSMutation(c.config, OpDelete)
	return &PROGRESSDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PROGRESSClient) DeleteOne(pr *PROGRESS) *PROGRESSDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PROGRESSClient) DeleteOneID(id int) *PROGRESSDeleteOne {
	builder := c.Delete().Where(progress.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PROGRESSDeleteOne{builder}
}

// Query returns a query builder for PROGRESS.
func (c *PROGRESSClient) Query() *PROGRESSQuery {
	return &PROGRESSQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePROGRESS},
		inters: c.Interceptors(),
	}
}

// Get returns a PROGRESS entity by its id.
func (c *PROGRESSClient) Get(ctx context.Context, id int) (*PROGRESS, error) {
	return c.Query().Where(progress.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PROGRESSClient) GetX(ctx context.Context, id int) *PROGRESS {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRecorded queries the recorded edge of a PROGRESS.
func (c *PROGRESSClient) QueryRecorded(pr *PROGRESS) *USERSQuery {
	query := (&USERSClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(progress.Table, progress.FieldID, id),
			sqlgraph.To(users.Table, users.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, progress.RecordedTable, progress.RecordedColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PROGRESSClient) Hooks() []Hook {
	return c.hooks.PROGRESS
}

// Interceptors returns the client interceptors.
func (c *PROGRESSClient) Interceptors() []Interceptor {
	return c.inters.PROGRESS
}

func (c *PROGRESSClient) mutate(ctx context.Context, m *PROGRESSMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PROGRESSCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PROGRESSUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PROGRESSUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PROGRESSDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PROGRESS mutation op: %q", m.Op())
	}
}

// SESSIONSClient is a client for the SESSIONS schema.
type SESSIONSClient struct {
	config
}

// NewSESSIONSClient returns a client for the SESSIONS from the given config.
func NewSESSIONSClient(c config) *SESSIONSClient {
	return &SESSIONSClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `sessions.Hooks(f(g(h())))`.
func (c *SESSIONSClient) Use(hooks ...Hook) {
	c.hooks.SESSIONS = append(c.hooks.SESSIONS, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `sessions.Intercept(f(g(h())))`.
func (c *SESSIONSClient) Intercept(interceptors ...Interceptor) {
	c.inters.SESSIONS = append(c.inters.SESSIONS, interceptors...)
}

// Create returns a builder for creating a SESSIONS entity.
func (c *SESSIONSClient) Create() *SESSIONSCreate {
	mutation := newSESSIONSMutation(c.config, OpCreate)
	return &SESSIONSCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SESSIONS entities.
func (c *SESSIONSClient) CreateBulk(builders ...*SESSIONSCreate) *SESSIONSCreateBulk {
	return &SESSIONSCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SESSIONSClient) MapCreateBulk(slice any, setFunc func(*SESSIONSCreate, int)) *SESSIONSCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SESSIONSCreateBulk{err: fmt.Errorf("calling to SESSIONSClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SESSIONSCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SESSIONSCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SESSIONS.
func (c *SESSIONSClient) Update() *SESSIONSUpdate {
	mutation := newSESSIONSMutation(c.config, OpUpdate)
	return &SESSIONSUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SESSIONSClient) UpdateOne(s *SESSIONS) *SESSIONSUpdateOne {
	mutation := newSESSIONSMutation(c.config, OpUpdateOne, withSESSIONS(s))
	return &SESSIONSUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SESSIONSClient) UpdateOneID(id int) *SESSIONSUpdateOne {
	mutation := newSESSIONSMutation(c.config, OpUpdateOne, withSESSIONSID(id))
	return &SESSIONSUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SESSIONS.
func (c *SESSIONSClient) Delete() *SESSIONSDelete {
	mutation := newSESSIONSMutation(c.config, OpDelete)
	return &SESSIONSDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SESSIONSClient) DeleteOne(s *SESSIONS) *SESSIONSDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SESSIONSClient) DeleteOneID(id int) *SESSIONSDeleteOne {
	builder := c.Delete().Where(sessions.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SESSIONSDeleteOne{builder}
}

// Query returns a query builder for SESSIONS.
func (c *SESSIONSClient) Query() *SESSIONSQuery {
	return &SESSIONSQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSESSIONS},
		inters: c.Interceptors(),
	}
}

// Get returns a SESSIONS entity by its id.
func (c *SESSIONSClient) Get(ctx context.Context, id int) (*SESSIONS, error) {
	return c.Query().Where(sessions.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SESSIONSClient) GetX(ctx context.Context, id int) *SESSIONS {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryHad queries the had edge of a SESSIONS.
func (c *SESSIONSClient) QueryHad(s *SESSIONS) *EVENTRECORDSQuery {
	query := (&EVENTRECORDSClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sessions.Table, sessions.FieldID, id),
			sqlgraph.To(event_records.Table, event_records.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, sessions.HadTable, sessions.HadColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMakes queries the makes edge of a SESSIONS.
func (c *SESSIONSClient) QueryMakes(s *SESSIONS) *CALLSQuery {
	query := (&CALLSClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(sessions.Table, sessions.FieldID, id),
			sqlgraph.To(calls.Table, calls.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, sessions.MakesTable, sessions.MakesColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SESSIONSClient) Hooks() []Hook {
	return c.hooks.SESSIONS
}

// Interceptors returns the client interceptors.
func (c *SESSIONSClient) Interceptors() []Interceptor {
	return c.inters.SESSIONS
}

func (c *SESSIONSClient) mutate(ctx context.Context, m *SESSIONSMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SESSIONSCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SESSIONSUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SESSIONSUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SESSIONSDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SESSIONS mutation op: %q", m.Op())
	}
}

// USERSClient is a client for the USERS schema.
type USERSClient struct {
	config
}

// NewUSERSClient returns a client for the USERS from the given config.
func NewUSERSClient(c config) *USERSClient {
	return &USERSClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `users.Hooks(f(g(h())))`.
func (c *USERSClient) Use(hooks ...Hook) {
	c.hooks.USERS = append(c.hooks.USERS, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `users.Intercept(f(g(h())))`.
func (c *USERSClient) Intercept(interceptors ...Interceptor) {
	c.inters.USERS = append(c.inters.USERS, interceptors...)
}

// Create returns a builder for creating a USERS entity.
func (c *USERSClient) Create() *USERSCreate {
	mutation := newUSERSMutation(c.config, OpCreate)
	return &USERSCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of USERS entities.
func (c *USERSClient) CreateBulk(builders ...*USERSCreate) *USERSCreateBulk {
	return &USERSCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *USERSClient) MapCreateBulk(slice any, setFunc func(*USERSCreate, int)) *USERSCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &USERSCreateBulk{err: fmt.Errorf("calling to USERSClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*USERSCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &USERSCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for USERS.
func (c *USERSClient) Update() *USERSUpdate {
	mutation := newUSERSMutation(c.config, OpUpdate)
	return &USERSUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *USERSClient) UpdateOne(u *USERS) *USERSUpdateOne {
	mutation := newUSERSMutation(c.config, OpUpdateOne, withUSERS(u))
	return &USERSUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *USERSClient) UpdateOneID(id int) *USERSUpdateOne {
	mutation := newUSERSMutation(c.config, OpUpdateOne, withUSERSID(id))
	return &USERSUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for USERS.
func (c *USERSClient) Delete() *USERSDelete {
	mutation := newUSERSMutation(c.config, OpDelete)
	return &USERSDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *USERSClient) DeleteOne(u *USERS) *USERSDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *USERSClient) DeleteOneID(id int) *USERSDeleteOne {
	builder := c.Delete().Where(users.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &USERSDeleteOne{builder}
}

// Query returns a query builder for USERS.
func (c *USERSClient) Query() *USERSQuery {
	return &USERSQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUSERS},
		inters: c.Interceptors(),
	}
}

// Get returns a USERS entity by its id.
func (c *USERSClient) Get(ctx context.Context, id int) (*USERS, error) {
	return c.Query().Where(users.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *USERSClient) GetX(ctx context.Context, id int) *USERS {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryConnects queries the connects edge of a USERS.
func (c *USERSClient) QueryConnects(u *USERS) *FRIENDSQuery {
	query := (&FRIENDSClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(users.Table, users.FieldID, id),
			sqlgraph.To(friends.Table, friends.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, users.ConnectsTable, users.ConnectsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMakes queries the makes edge of a USERS.
func (c *USERSClient) QueryMakes(u *USERS) *EVENTRECORDSQuery {
	query := (&EVENTRECORDSClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(users.Table, users.FieldID, id),
			sqlgraph.To(event_records.Table, event_records.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, users.MakesTable, users.MakesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPrepares queries the prepares edge of a USERS.
func (c *USERSClient) QueryPrepares(u *USERS) *MEMOSQuery {
	query := (&MEMOSClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(users.Table, users.FieldID, id),
			sqlgraph.To(memos.Table, memos.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, users.PreparesTable, users.PreparesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAcquires queries the acquires edge of a USERS.
func (c *USERSClient) QueryAcquires(u *USERS) *ACHIEVEMENTSQuery {
	query := (&ACHIEVEMENTSClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(users.Table, users.FieldID, id),
			sqlgraph.To(achievements.Table, achievements.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, users.AcquiresTable, users.AcquiresColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRecords queries the records edge of a USERS.
func (c *USERSClient) QueryRecords(u *USERS) *PROGRESSQuery {
	query := (&PROGRESSClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(users.Table, users.FieldID, id),
			sqlgraph.To(progress.Table, progress.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, users.RecordsTable, users.RecordsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *USERSClient) Hooks() []Hook {
	return c.hooks.USERS
}

// Interceptors returns the client interceptors.
func (c *USERSClient) Interceptors() []Interceptor {
	return c.inters.USERS
}

func (c *USERSClient) mutate(ctx context.Context, m *USERSMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&USERSCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&USERSUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&USERSUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&USERSDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown USERS mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		ACHIEVEMENTS, AI_THEMES, CALLS, CHATS, EVENTS, EVENT_RECORDS, FRIENDS, MEMOS,
		PROGRESS, SESSIONS, USERS []ent.Hook
	}
	inters struct {
		ACHIEVEMENTS, AI_THEMES, CALLS, CHATS, EVENTS, EVENT_RECORDS, FRIENDS, MEMOS,
		PROGRESS, SESSIONS, USERS []ent.Interceptor
	}
)
